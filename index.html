<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Horas Planet√°rias</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      background: linear-gradient(to bottom, #1a1a2e, #0f3460);
      color: #fff;
      margin: 0;
      padding: 20px;
    }
    .container {
      max-width: 90%;
      width: 600px;
      margin: auto;
      padding: 20px;
      background: rgba(22, 33, 62, 0.9);
      border-radius: 10px;
      box-shadow: 0 4px 10px rgba(255, 255, 255, 0.2);
    }
    h1, h2 {
      color: #f8b400;
      margin-bottom: 10px;
    }
    /* Molduras para os campos */
    .planet-info {
      margin: 20px 0;
      padding: 15px;
      background: rgba(15, 52, 96, 0.8);
      border-radius: 5px;
    }
    .tempo-restante, .adjacent-hours {
      color: #f8b400;
      font-size: 0.8em;
      margin-top: 5px;
    }
    .button {
      padding: 12px 24px;
      font-size: 16px;
      font-weight: bold;
      background-color: #f8b400;
      color: #1a1a2e;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    .button:hover {
      background-color: #ffcc29;
    }
    /* Oculta a mensagem de status de localiza√ß√£o */
    #location-status {
      display: none;
    }
    /* Cidade e estado em negrito */
    #city-name {
      font-weight: bold;
    }
    @media (max-width: 768px) {
      .container {
        width: 95%;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Horas Planet√°rias</h1>
    <p>Confira o dia e a hora planet√°ria atual baseado na sua localiza√ß√£o.</p>
    
    <!-- Moldura para o Dia Planet√°rio -->
    <div class="planet-info" id="dia-planetario-container">
      <h2>Dia Planet√°rio: <span id="dia-planetario">...</span></h2>
      <p class="tempo-restante" id="tempo-passado">O Sol nasceu h√°: --:--:--</p>
      <p class="tempo-restante" id="tempo-ate-p√¥r">O Sol se p√µe em: --:--:--</p>
    </div>
    
    <!-- Moldura para a Hora Planet√°ria -->
    <div class="planet-info" id="hora-planetaria-container">
      <h2>Hora Planet√°ria Atual: <span id="planet-icon">üîÜ</span> <span id="hora-planetaria">...</span></h2>
      <p class="tempo-restante">Tempo Restante: <span id="cronometro">--:--:--</span></p>
      <p class="adjacent-hours">
        Hora Anterior: <span id="hora-anterior">...</span> | Pr√≥xima Hora: <span id="proxima-hora">...</span>
      </p>
    </div>
    
    <button class="button" onclick="getLocation()">Detectar Localiza√ß√£o</button>
    <p id="location-status">Localiza√ß√£o n√£o detectada.</p>
    <p id="city-name">Cidade n√£o detectada.</p>
    <p id="sunrise-sunset">
      Nascer do Sol: <span id="sunrise-time">--:--</span> | P√¥r do Sol: <span id="sunset-time">--:--</span>
    </p>
  </div>
  
  <script>
    // Novo mapeamento para o Dia Planet√°rio: √çcone e nome do deus
    const firstHourMapping = [
      "‚ôÑ Cronos/Saturno",
      "‚òâ H√©lios/Sol",
      "‚òΩ Selene/Lua",
      "‚ôÇ Ares/Marte",
      "‚òø Hermes/Merc√∫rio",
      "‚ôÉ Zeus/J√∫piter",
      "‚ôÄ Afrodite/V√™nus"
    ];
    // Ordem caldeia fixa (do mais lento para o mais r√°pido) permanece inalterada
    const chaldeanOrder = ["‚ôÑ Saturno", "‚ôÉ J√∫piter", "‚ôÇ Marte", "‚òâ Sol", "‚ôÄ V√™nus", "‚òø Merc√∫rio", "‚òΩ Lua"];
  
    function getLocation() {
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(showPosition, showError);
      } else {
        document.getElementById("location-status").innerText = "Geolocaliza√ß√£o n√£o suportada pelo navegador.";
      }
    }
  
    function showPosition(position) {
      // Oculta os dados de latitude e longitude; exibe apenas "Localiza√ß√£o detectada."
      document.getElementById("location-status").innerText = "Localiza√ß√£o detectada.";
      let lat = position.coords.latitude;
      let lon = position.coords.longitude;
      getSunTimes(lat, lon);
      getCityName(lat, lon);
    }
  
    function getCityName(lat, lon) {
      let url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}`;
      fetch(url)
        .then(response => response.json())
        .then(data => {
          let city = data.address.city || data.address.town || data.address.village || "Cidade desconhecida";
          let state = data.address.state || "Estado desconhecido";
          document.getElementById("city-name").innerText = `Cidade: ${city}, ${state}`;
        })
        .catch(error => {
          console.error("Erro ao obter o nome da cidade:", error);
          document.getElementById("city-name").innerText = "Erro ao obter a cidade.";
        });
    }
  
    function showError(error) {
      document.getElementById("location-status").innerText = "Erro ao obter localiza√ß√£o.";
    }
  
    function getSunTimes(lat, lon) {
      let url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&daily=sunrise,sunset&timezone=auto`;
      fetch(url)
        .then(response => response.json())
        .then(data => {
          let sunrise = new Date(data.daily.sunrise[0]);
          let sunset = new Date(data.daily.sunset[0]);
          // nextSunrise √© 24h ap√≥s o nascer de hoje, conforme fornecido pela API
          let nextSunrise = new Date(sunrise.getTime() + 24 * 60 * 60 * 1000);
  
          let sunriseFormatted = sunrise.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
          let sunsetFormatted = sunset.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
          document.getElementById("sunrise-time").innerText = sunriseFormatted;
          document.getElementById("sunset-time").innerText = sunsetFormatted;
  
          calculatePlanetaryHours(sunrise, sunset, nextSunrise);
          // Inicia os marcadores de tempo:
          startElapsedTimeTimer(sunrise, sunset);
          startTimeUntilSunset(sunset, nextSunrise);
        })
        .catch(error => {
          console.error("Erro ao obter hor√°rios do sol:", error);
          document.getElementById("sunrise-time").innerText = "Erro";
          document.getElementById("sunset-time").innerText = "Erro";
        });
    }
  
    function calculatePlanetaryHours(sunrise, sunset, nextSunrise) {
      let today = new Date();
      let currentTime = today;
      let startDayIndex; // √çndice para determinar o dia (para a sequ√™ncia planet√°ria)
  
      // Se o hor√°rio atual for antes do nascer, usamos os hor√°rios do dia anterior
      if (currentTime < sunrise) {
        let prevSunrise = new Date(sunrise.getTime() - 24 * 60 * 60 * 1000);
        let prevSunset = new Date(sunset.getTime() - 24 * 60 * 60 * 1000);
        nextSunrise = sunrise; // pr√≥ximo nascer √© o de hoje
        sunrise = prevSunrise;
        sunset = prevSunset;
        startDayIndex = (today.getDay() + 6) % 7; // dia anterior
      } else {
        startDayIndex = today.getDay();
      }
  
      // Exibe o Dia Planet√°rio conforme o mapeamento da primeira hora (agora com deuses)
      document.getElementById("dia-planetario").innerText = firstHourMapping[startDayIndex];
  
      // Define o planeta que rege a primeira hora do dia a partir do mapeamento
      let firstHourPlanet = firstHourMapping[startDayIndex];
      // Procura esse planeta na ordem caldeia para determinar o ponto de partida
      let firstHourIndex = chaldeanOrder.indexOf(firstHourPlanet.split(" ")[1]); 
      // Aqui usamos .split(" ")[1] para extrair o segundo termo (por exemplo, de "‚ôÑ Cronos/Saturno", usamos "Cronos/Saturno")
      // Entretanto, se preferir usar o √≠cone, pode-se ajustar conforme necess√°rio.
  
      // Gera a sequ√™ncia de 24 horas planet√°rias (usando a ordem caldeia)
      let planetaryHours = [];
      for (let i = 0; i < 24; i++) {
        planetaryHours.push(chaldeanOrder[(firstHourIndex + i) % 7]);
      }
  
      // Divide o per√≠odo em 12 horas diurnas e 12 noturnas
      let dayDuration = (sunset - sunrise) / 12;
      let nightDuration = (nextSunrise - sunset) / 12;
  
      let intervalStart, intervalEnd;
      let currentHourIndex; // √çndice 1-based (de 1 a 24)
  
      if (currentTime >= sunrise && currentTime < sunset) {
        // Per√≠odo diurno
        let h = Math.floor((currentTime - sunrise) / dayDuration); // 0 a 11
        currentHourIndex = h + 1; // 1 a 12
        intervalStart = new Date(sunrise.getTime() + h * dayDuration);
        intervalEnd = new Date(intervalStart.getTime() + dayDuration);
      } else if (currentTime >= sunset && currentTime < nextSunrise) {
        // Per√≠odo noturno
        let h = Math.floor((currentTime - sunset) / nightDuration); // 0 a 11
        currentHourIndex = 12 + h + 1; // 13 a 24
        intervalStart = new Date(sunset.getTime() + h * nightDuration);
        intervalEnd = new Date(intervalStart.getTime() + nightDuration);
      } else if (currentTime < sunrise) {
        // Antes do nascer: √∫ltima hora (24)
        currentHourIndex = 24;
        intervalEnd = sunrise;
        intervalStart = new Date(sunrise.getTime() - nightDuration);
      } else {
        // Caso incomum: ap√≥s o pr√≥ximo nascer
        currentHourIndex = 1;
        intervalStart = nextSunrise;
        intervalEnd = new Date(nextSunrise.getTime() + dayDuration);
      }
  
      // Atualiza os elementos da interface usando o √≠ndice 1-based:
      let currentPlanet = planetaryHours[currentHourIndex - 1];
      let currentParts = currentPlanet.split(" ");
      document.getElementById("planet-icon").innerText = currentParts[0];
      document.getElementById("hora-planetaria").innerText = currentParts.slice(1).join(" ");
  
      let previousPlanet = planetaryHours[(currentHourIndex - 2 + 24) % 24];
      document.getElementById("hora-anterior").innerText = previousPlanet;
  
      let nextPlanet = planetaryHours[(currentHourIndex) % 24];
      document.getElementById("proxima-hora").innerText = nextPlanet;
  
      // Inicia o cron√¥metro para o t√©rmino do intervalo da hora atual
      startCronometro(intervalEnd);
    }
  
    function startCronometro(endTime) {
      if (window.cronometroInterval) clearInterval(window.cronometroInterval);
      window.cronometroInterval = setInterval(() => {
        const now = new Date();
        const diff = endTime - now;
        if (diff <= 0) {
          document.getElementById("cronometro").innerText = "00:00:00";
          clearInterval(window.cronometroInterval);
        } else {
          const totalSeconds = Math.floor(diff / 1000);
          const hours = Math.floor(totalSeconds / 3600);
          const minutes = Math.floor((totalSeconds % 3600) / 60);
          const seconds = totalSeconds % 60;
          const formatted = 
            (hours < 10 ? "0" + hours : hours) + ":" +
            (minutes < 10 ? "0" + minutes : minutes) + ":" +
            (seconds < 10 ? "0" + seconds : seconds);
          document.getElementById("cronometro").innerText = formatted;
        }
      }, 1000);
    }
  
    // Atualiza o marcador de tempo decorrido:
    // Se o Sol ainda n√£o se p√¥s: "O Sol nasceu h√°:"; se j√° passou do p√¥r: "O Sol se p√¥s h√°:"
    function startElapsedTimeTimer(sunrise, sunset) {
      if (window.elapsedTimeInterval) clearInterval(window.elapsedTimeInterval);
      window.elapsedTimeInterval = setInterval(() => {
        let now = new Date();
        let diff, label;
        if (now < sunset) {
          diff = now - sunrise;
          label = "O Sol nasceu h√°: ";
        } else {
          diff = now - sunset;
          label = "O Sol se p√¥s h√°: ";
        }
        if (diff < 0) diff = 0;
        const totalSeconds = Math.floor(diff / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        const formatted = 
          (hours < 10 ? "0" + hours : hours) + ":" +
          (minutes < 10 ? "0" + minutes : minutes) + ":" +
          (seconds < 10 ? "0" + seconds : seconds);
        document.getElementById("tempo-passado").innerText = label + formatted;
      }, 1000);
    }
  
    // Atualiza o marcador de tempo at√© o pr√≥ximo evento:
    // Se o Sol ainda n√£o se p√¥s: "O Sol se p√µe em:"; se j√° passou do p√¥r: "O Sol nascer√° em:"
    function startTimeUntilSunset(sunset, nextSunrise) {
      if (window.sunsetInterval) clearInterval(window.sunsetInterval);
      window.sunsetInterval = setInterval(() => {
        let now = new Date();
        let diff, label;
        if (now < sunset) {
          diff = sunset - now;
          label = "O Sol se p√µe em: ";
        } else {
          diff = nextSunrise - now;
          label = "O Sol nascer√° em: ";
        }
        if (diff < 0) diff = 0;
        const totalSeconds = Math.floor(diff / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        const formatted = 
          (hours < 10 ? "0" + hours : hours) + ":" +
          (minutes < 10 ? "0" + minutes : minutes) + ":" +
          (seconds < 10 ? "0" + seconds : seconds);
        document.getElementById("tempo-ate-p√¥r").innerText = label + formatted;
      }, 1000);
    }
  </script>
  
</body>
</html>
