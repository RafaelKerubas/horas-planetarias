function showPosition(position) {
  document.getElementById("location-status").innerText = "Localiza√ß√£o detectada.";
  let lat = position.coords.latitude;
  let lon = position.coords.longitude;
  getSunTimes(lat, lon);
  getCityName(lat, lon);
  updateMoonInfo(lat, lon); // Atualiza a moldura lunar
}
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Horas Planet√°rias</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      background: linear-gradient(to bottom, #1a1a2e, #0f3460);
      color: #fff;
      margin: 0;
      padding: 20px;
    }
    .container {
      max-width: 90%;
      width: 600px;
      margin: auto;
      padding: 20px;
      background: rgba(22, 33, 62, 0.9);
      border-radius: 10px;
      box-shadow: 0 4px 10px rgba(255, 255, 255, 0.2);
    }
    h1, h2 {
      color: #f8b400;
      margin-bottom: 10px;
    }
    /* Molduras para os campos */
    .planet-info {
      margin: 20px 0;
      padding: 15px;
      background: rgba(15, 52, 96, 0.8);
      border-radius: 5px;
    }
    .tempo-restante, .adjacent-hours, #info-message, .day-definition {
      color: #f8b400;
      font-size: 0.8em;
      margin-top: 5px;
    }
    .button {
      padding: 12px 24px;
      font-size: 16px;
      font-weight: bold;
      background-color: #f8b400;
      color: #1a1a2e;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    .button:hover {
      background-color: #ffcc29;
    }
    #location-status {
      display: none;
    }
    #city-name {
      font-weight: bold;
    }
    @media (max-width: 768px) {
      .container {
        width: 95%;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Horas Planet√°rias</h1>
    <p>Confira o dia e a hora planet√°ria atual baseado na sua localiza√ß√£o.</p>
    
    <!-- Primeira moldura: Planeta Regente -->
    <div class="planet-info" id="dia-planetario-container">
      <h2>Planeta Regente: <span id="dia-planetario">...</span></h2>
      <!-- Day-definition logo abaixo do t√≠tulo -->
      <p class="day-definition" id="day-definition">( )</p>
      <!-- Cron√¥metros combinados em uma √∫nica linha -->
      <p class="tempo-restante" id="tempo-timers">
        <span id="tempo-passado">O Sol nasceu h√°: --:--:--</span> | 
        <span id="tempo-ate-p√¥r">O Sol se p√µe em: --:--:--</span>
      </p>
    </div>
    
    <!-- Segunda moldura: Informa√ß√µes adicionais -->
    <div class="planet-info" id="info-container">
      <h2 id="info-title">...</h2>
      <p id="info-message"></p>
    </div>
    
    <!-- Terceira moldura: Hora Planet√°ria Atual -->
    <div class="planet-info" id="hora-planetaria-container">
      <h2>Hora Planet√°ria Atual: <span id="planet-icon">üîÜ</span> <span id="hora-planetaria">...</span></h2>
      <p class="tempo-restante">Tempo Restante: <span id="cronometro">--:--:--</span></p>
      <p class="adjacent-hours">
        Hora Anterior: <span id="hora-anterior">...</span> | Pr√≥xima Hora: <span id="proxima-hora">...</span>
      </p>
    </div>
    
    <button class="button" onclick="getLocation()">Detectar Localiza√ß√£o</button>
    <p id="location-status">Localiza√ß√£o n√£o detectada.</p>
    <p id="city-name">Cidade n√£o detectada.</p>
    <p id="sunrise-sunset">
      Nascer do Sol: <span id="sunrise-time">--:--</span> | P√¥r do Sol: <span id="sunset-time">--:--</span>
    </p>
  </div>
  
  <script>
    // Configura√ß√µes dos dados para cada dia da semana

    // Mapeamento para o Planeta Regente com deuses:
    const firstHourMapping = [
      "‚òâ H√©lios/Sol",
      "‚òΩ Selene/Lua",
      "‚ôÇ Ares/Marte",
      "‚òø Hermes/Merc√∫rio",
      "‚ôÉ Zeus/J√∫piter",
      "‚ôÄ Afrodite/V√™nus",
      "‚ôÑ Cronos/Saturno"
    ];
    // Ordem caldeia padr√£o
    const chaldeanOrder = ["‚ôÑ Saturno", "‚ôÉ J√∫piter", "‚ôÇ Marte", "‚òâ Sol", "‚ôÄ V√™nus", "‚òø Merc√∫rio", "‚òΩ Lua"];
    // Nomes dos dias da semana
    const dayNames = ["Domingo", "Segunda-feira", "Ter√ßa-feira", "Quarta-feira", "Quinta-feira", "Sexta-feira", "S√°bado"];
    // Defini√ß√µes para cada dia (apenas as frases)
    const dayDefinitions = {
      "Domingo": "Dia de vitalidade, brilho pessoal e lideran√ßa. Ideal para rituais de fortalecimento da identidade, sucesso, autoestima e visibilidade.",
      "Segunda-feira": "Ligada √†s emo√ß√µes, intui√ß√£o e mem√≥ria ancestral. Excelente para pr√°ticas de autoconhecimento, cura emocional e conex√£o com o feminino.",
      "Ter√ßa-feira": "Energia de a√ß√£o, coragem e vontade. Favor√°vel para feiti√ßos de prote√ß√£o, supera√ß√£o de obst√°culos e in√≠cio de empreitadas ousadas.",
      "Quarta-feira": "Regida pela mente e pela comunica√ß√£o. Indicado para trabalhos m√°gicos ligados a estudo, escrita, com√©rcio, viagens e eloqu√™ncia.",
      "Quinta-feira": "Vibra√ß√£o de expans√£o, sorte e sabedoria. Potente para rituais de crescimento, justi√ßa, gratid√£o, f√© e prosperidade.",
      "Sexta-feira": "Harmonia, prazer e beleza em destaque. √ìtima para encantamentos voltados ao amor, √† arte, √† autoestima e √† atra√ß√£o.",
      "S√°bado": "Estrutura, disciplina e introspec√ß√£o. Prop√≠cio para banimentos, encerramentos de ciclos, prote√ß√£o e fortalecimento espiritual."
    };
  
    // Configura√ß√µes espec√≠ficas para cada dia (exemplo: Domingo e S√°bado)
    const dayConfigurations = {
      "Domingo": {
        sequence: ["‚òâ Sol", "‚ôÄ V√™nus", "‚òø Merc√∫rio", "‚òΩ Lua", "‚ôÑ Saturno", "‚ôÉ J√∫piter", "‚ôÇ Marte"],
        messages: [
          "Fazendo um discurso",
          "Ganhando o amor de um senhor",
          "Para se dirigir aos senhores",
          "Para um encontro com um senhor",
          "Pode impedir um encontro com um senhor",
          "Pode comparecer perante um senhor",
          "Fazer nada",
          "Para qualquer coisa sobre senhores",
          "Para qualquer coisa sobre amor",
          "Pode escrever uma peti√ß√£o",
          "Pode fazer um discurso",
          "Fazer nada",
          "Pode ajudar os amigos",
          "Para impedir um discurso",
          "Pode enviar sonhos a um rei",
          "Pode enviar sonhos a uma senhora",
          "Fazer nada",
          "Trabalhar",
          "Fazer nada",
          "Magia ou talism√£s para o amor dos senhores",
          "Para amarrar e restringir outros",
          "Pode comparecer perante um rei",
          "Pode aparecer diante de uma senhora",
          "Descanse, n√£o fa√ßa nada"
        ]
      },
      "S√°bado": {
        sequence: ["‚ôÑ Saturno", "‚ôÉ J√∫piter", "‚ôÇ Marte", "‚òâ Sol", "‚ôÄ V√™nus", "‚òø Merc√∫rio", "‚òΩ Lua"],
        messages: [
          "Magia ou talism√£s para ferir seu inimigo ou enviar doen√ßas",       // 1¬™
          "Pode causar um naufr√°gio ou prejudicar algu√©m",                      // 2¬™
          "Para configurar encantamentos",                                      // 3¬™
          "Pode fazer os senhores lutarem entre si",                           // 4¬™
          "Pode causar √≥dio entre um casal",                                    // 5¬™
          "Pode encontrar o tesouro",                                           // 6¬™
          "Pode falar com dem√¥nios",                                             // 7¬™
          "Para realizar a adivinha√ß√£o da bacia",                               // 8¬™
          "Para realizar a adivinha√ß√£o do cr√¢nio",                                // 9¬™
          "Pode fazer com que os povos mergulhem no mar",                        // 10¬™
          "Pode deixar os litigantes furiosos uns com os outros",                // 11¬™
          "Pode causar medo e inimizade",                                       // 12¬™
          "Ben√©fico para descobrir segredos",                                  // 13¬™
          "Pode ver pessoas mortas",                                            // 14¬™
          "Para ter vis√µes ‚Äì Para adivinha√ß√£o de √°gua",                           // 15¬™
          "√ötil para ensinar",                                                  // 16¬™
          "Hora muito maligna",                                                 // 17¬™
          "Hora in√∫til",                                                        // 18¬™
          "Para ganhar dinheiro em dados",                                      // 19¬™
          "Pode conter todas as coisas boas",                                   // 20¬™
          "Hora sem virtude",                                                   // 21¬™
          "Pode causar vis√µes",                                                 // 22¬™
          "√ötil para lucro",                                                    // 23¬™
          "Hora de aborrecimento e inimizade"                                   // 24¬™
        ]
      }
      // Outras configura√ß√µes para os demais dias podem ser adicionadas...
    };
  
    function getLocation() {
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(showPosition, showError);
      } else {
        document.getElementById("location-status").innerText = "Geolocaliza√ß√£o n√£o suportada pelo navegador.";
      }
    }
  
    function showPosition(position) {
      document.getElementById("location-status").innerText = "Localiza√ß√£o detectada.";
      let lat = position.coords.latitude;
      let lon = position.coords.longitude;
      getSunTimes(lat, lon);
      getCityName(lat, lon);
    }
  
    function getCityName(lat, lon) {
      let url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}`;
      fetch(url)
        .then(response => response.json())
        .then(data => {
          let city = data.address.city || data.address.town || data.address.village || "Cidade desconhecida";
          let state = data.address.state || "Estado desconhecido";
          document.getElementById("city-name").innerText = `Cidade: ${city}, ${state}`;
        })
        .catch(error => {
          console.error("Erro ao obter o nome da cidade:", error);
          document.getElementById("city-name").innerText = "Erro ao obter a cidade.";
        });
    }
  
    function showError(error) {
      document.getElementById("location-status").innerText = "Erro ao obter localiza√ß√£o.";
    }
  
    function getSunTimes(lat, lon) {
      let url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&daily=sunrise,sunset&timezone=auto`;
      fetch(url)
        .then(response => response.json())
        .then(data => {
          let sunrise = new Date(data.daily.sunrise[0]);
          let sunset = new Date(data.daily.sunset[0]);
          let nextSunrise = new Date(sunrise.getTime() + 24 * 60 * 60 * 1000);
  
          let sunriseFormatted = sunrise.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
          let sunsetFormatted = sunset.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
          document.getElementById("sunrise-time").innerText = sunriseFormatted;
          document.getElementById("sunset-time").innerText = sunsetFormatted;
  
          // Armazena valores globalmente para o refresh autom√°tico
          window.sunrise = sunrise;
          window.sunset = sunset;
          window.nextSunrise = nextSunrise;
  
          calculatePlanetaryHours(sunrise, sunset, nextSunrise);
          startElapsedTimeTimer(sunrise, sunset);
          startTimeUntilSunset(sunset, nextSunrise);
        })
        .catch(error => {
          console.error("Erro ao obter hor√°rios do sol:", error);
          document.getElementById("sunrise-time").innerText = "Erro";
          document.getElementById("sunset-time").innerText = "Erro";
        });
    }
  
    function calculatePlanetaryHours(sunrise, sunset, nextSunrise) {
      let today = new Date();
      let currentTime = today;
      let startDayIndex;
  
      if (currentTime < sunrise) {
        let prevSunrise = new Date(sunrise.getTime() - 24 * 60 * 60 * 1000);
        let prevSunset = new Date(sunset.getTime() - 24 * 60 * 60 * 1000);
        nextSunrise = sunrise;
        sunrise = prevSunrise;
        sunset = prevSunset;
        startDayIndex = (today.getDay() + 6) % 7;
      } else {
        startDayIndex = today.getDay();
      }
  
      document.getElementById("dia-planetario").innerText = firstHourMapping[startDayIndex];
      // Atualiza a defini√ß√£o do dia (apenas a frase)
      document.getElementById("day-definition").innerText = dayDefinitions[dayNames[startDayIndex]];
  
      let config = dayConfigurations[dayNames[startDayIndex]];
      let planetaryHours = [];
      if (config && config.sequence) {
        for (let i = 0; i < 24; i++) {
          planetaryHours.push(config.sequence[i % config.sequence.length]);
        }
      } else {
        let firstHourPlanet = firstHourMapping[startDayIndex];
        let icon = firstHourPlanet.charAt(0);
        let firstHourIndex = chaldeanOrder.findIndex(el => el.startsWith(icon));
        for (let i = 0; i < 24; i++) {
          planetaryHours.push(chaldeanOrder[(firstHourIndex + i) % 7]);
        }
      }
  
      let dayDuration = (sunset - sunrise) / 12;
      let nightDuration = (nextSunrise - sunset) / 12;
  
      let intervalStart, intervalEnd;
      let currentHourIndex;
  
      if (currentTime >= sunrise && currentTime < sunset) {
        let h = Math.floor((currentTime - sunrise) / dayDuration);
        currentHourIndex = h + 1;
        intervalStart = new Date(sunrise.getTime() + h * dayDuration);
        intervalEnd = new Date(intervalStart.getTime() + dayDuration);
      } else if (currentTime >= sunset && currentTime < nextSunrise) {
        let h = Math.floor((currentTime - sunset) / nightDuration);
        currentHourIndex = 12 + h + 1;
        intervalStart = new Date(sunset.getTime() + h * nightDuration);
        intervalEnd = new Date(intervalStart.getTime() + nightDuration);
      } else if (currentTime < sunrise) {
        currentHourIndex = 24;
        intervalEnd = sunrise;
        intervalStart = new Date(sunrise.getTime() - nightDuration);
      } else {
        currentHourIndex = 1;
        intervalStart = nextSunrise;
        intervalEnd = new Date(nextSunrise.getTime() + dayDuration);
      }
  
      let currentPlanet = planetaryHours[currentHourIndex - 1];
      document.getElementById("planet-icon").innerText = currentPlanet;
  
      let previousPlanet = planetaryHours[(currentHourIndex - 2 + 24) % 24];
      document.getElementById("hora-anterior").innerText = previousPlanet;
  
      let nextPlanet = planetaryHours[(currentHourIndex) % 24];
      document.getElementById("proxima-hora").innerText = nextPlanet;
  
      startCronometro(intervalEnd);
  
      let dayTitle = dayNames[startDayIndex];
      let ordinal = currentHourIndex + "¬™";
      document.getElementById("info-title").innerText = dayTitle + " - " + ordinal + " Hora";
  
      if (config && config.messages) {
        document.getElementById("info-message").innerText = config.messages[currentHourIndex - 1];
      } else {
        document.getElementById("info-message").innerText = "";
      }
    }
  
    function startCronometro(endTime) {
      if (window.cronometroInterval) clearInterval(window.cronometroInterval);
      window.cronometroInterval = setInterval(() => {
        const now = new Date();
        const diff = endTime - now;
        if (diff <= 0) {
          document.getElementById("cronometro").innerText = "00:00:00";
          clearInterval(window.cronometroInterval);
          // Atualiza automaticamente para a pr√≥xima hora
          calculatePlanetaryHours(window.sunrise, window.sunset, window.nextSunrise);
        } else {
          const totalSeconds = Math.floor(diff / 1000);
          const hours = Math.floor(totalSeconds / 3600);
          const minutes = Math.floor((totalSeconds % 3600) / 60);
          const seconds = totalSeconds % 60;
          const formatted =
            (hours < 10 ? "0" + hours : hours) + ":" +
            (minutes < 10 ? "0" + minutes : minutes) + ":" +
            (seconds < 10 ? "0" + seconds : seconds);
          document.getElementById("cronometro").innerText = formatted;
        }
      }, 1000);
    }
  
    function startElapsedTimeTimer(sunrise, sunset) {
      if (window.elapsedTimeInterval) clearInterval(window.elapsedTimeInterval);
      window.elapsedTimeInterval = setInterval(() => {
        let now = new Date();
        let diff, label;
        if (now < sunset) {
          diff = now - sunrise;
          label = "O Sol nasceu h√°: ";
        } else {
          diff = now - sunset;
          label = "O Sol se p√¥s h√°: ";
        }
        if (diff < 0) diff = 0;
        const totalSeconds = Math.floor(diff / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        const formatted =
          (hours < 10 ? "0" + hours : hours) + ":" +
          (minutes < 10 ? "0" + minutes : minutes) + ":" +
          (seconds < 10 ? "0" + seconds : seconds);
        document.getElementById("tempo-passado").innerText = label + formatted;
      }, 1000);
    }
  
    function startTimeUntilSunset(sunset, nextSunrise) {
      if (window.sunsetInterval) clearInterval(window.sunsetInterval);
      window.sunsetInterval = setInterval(() => {
        let now = new Date();
        let diff, label;
        if (now < sunset) {
          diff = sunset - now;
          label = "O Sol se p√µe em: ";
        } else {
          diff = nextSunrise - now;
          label = "O Sol nascer√° em: ";
        }
        if (diff < 0) diff = 0;
        const totalSeconds = Math.floor(diff / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        const formatted =
          (hours < 10 ? "0" + hours : hours) + ":" +
          (minutes < 10 ? "0" + minutes : minutes) + ":" +
          (seconds < 10 ? "0" + seconds : seconds);
        document.getElementById("tempo-ate-p√¥r").innerText = label + formatted;
      }, 1000);
    }
  </script>
  
</body>
</html>
